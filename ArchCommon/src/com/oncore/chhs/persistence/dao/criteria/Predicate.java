/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.oncore.chhs.persistence.dao.criteria;

import java.util.ArrayList;
import java.util.List;
import javax.persistence.TypedQuery;
import javax.persistence.metamodel.SingularAttribute;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

/**
 * Add multiple FilterCriteria together to string together where clause
 * fragments to filter a result set. Note that this implementation is not
 * a replacement for CriteriaBuilder API but will suffice for internal use
 * within DAO instances to write most simple queries. The benefit is that no
 * JPQL needs to be generated by hand and if the table/column changes 
 * compile warnings in the workspace will immediately notify developers that
 * code must be changed/fixed to accommodate the change.
 * 
 * @param <T> The entity type.
 * @param <V> The data value type.
 * 
 * @author Kerry O'Brien
 * 
 * @see FilterCriteria
 */
@XmlRootElement
@XmlAccessorType( XmlAccessType.FIELD )
public class Predicate<T,V> {
    private Conjunction conjunction = Conjunction.AND;
    @XmlElement( name="filterCriteria" )
    private List<FilterCriteria<T,V>> filterCriteria;
    
    /**
     * Add simple filters using the #addSimpleFilter method.
     */
    public Predicate( ) {
        
    }
    
    /**
     * 
     * @param filterCriteria  A FilterCriteria.
     */
    public Predicate( FilterCriteria<T,V> filterCriteria ) {
        this.filterCriteria = new ArrayList();
        
        this.filterCriteria.add( filterCriteria );
    }
    
    /**
     * 
     * @param conjunction A Conjunction.
     * @param filterCriteria  A list of FilterCriteria.
     */
    public Predicate( Conjunction conjunction, List<FilterCriteria<T,V>> filterCriteria ) {
        this.conjunction = conjunction;
        this.filterCriteria = filterCriteria;
    }
    
    /**
     * 
     * @param filterCriteria A FilterCriteria.
     */
    public void addFilterCriteria( FilterCriteria<T,V> filterCriteria ) {
        this.filterCriteria.add( filterCriteria );
    }
    
    /**
     * 
     * @param index The index.
     * @return The FilterCriteria.
     */
    public FilterCriteria<T,V> getFilterCriteria( int index ) {
        return this.filterCriteria.get( index );
    }
    
    /**
     * 
     * @param builder A StringBuilder.
     * @param filterCriteriaIndex Index to keep parameters unique when adding
     * more than one Predicate.
     */
    public void addFilters( StringBuilder builder, int filterCriteriaIndex ) {
        FilterCriteria crit;
        for ( int i = 0;this.filterCriteria != null && i < this.filterCriteria.size();i++) {
            if ( i == 0 ) {
                if ( this.filterCriteria.size() > 1 ) {
                    builder.append( "(" );
                }
            } else {
                builder.append( " " );
                builder.append( this.conjunction );
                builder.append( " " );
            }
            
            crit = this.filterCriteria.get( i );
            
            crit.addJPQL( builder, filterCriteriaIndex );
        }

        if ( this.filterCriteria != null && this.filterCriteria.size() > 1 ) {
            builder.append( ")" );
        }
    }
    
    /**
     * 
     * @param typedQuery The TypedQuery.
     * @param filterCriteriaIndex Index to keep parameters unique when adding
     * more than one Predicate. 
     */
    public void setParameters( TypedQuery<T> typedQuery, int filterCriteriaIndex ) {
        FilterCriteria<T,V> crit;
        for ( int i = 0;this.filterCriteria != null && i < this.filterCriteria.size();i++) {   
            crit = this.filterCriteria.get( i );
            
            crit.setParameterValue( typedQuery, filterCriteriaIndex );
        }        
    }
    
    /**
     * 
     * @param conjunction Whether multiple filter criteria should be joined
     * together using AND or OR.
     */
    public void setConjunction( Conjunction conjunction ) {
        this.conjunction = conjunction;
    }
    
    /**
     * 
     * @param attribute A SingularAttribute.
     * @param values One or more values.
     */
    public void addSimpleFilter( SingularAttribute<T,?> attribute, List<String> values ) {
        if ( this.filterCriteria == null ) {
            this.filterCriteria = new ArrayList();
        }
        
        this.filterCriteria.add( new FilterCriteriaImpl( attribute, 
                values ) );
    }
    
    /**
     * 
     * @param attribute A SingularAttribute.
     * @param values One or more values.
     */
    public void addSimpleNumericFilter( SingularAttribute<T,?> attribute, List<? extends Number> values ) {
        if ( this.filterCriteria == null ) {
            this.filterCriteria = new ArrayList();
        }
        
        this.filterCriteria.add( new NumericFilterCriteriaImpl(attribute, 
                values ) );
    }
    
    /**
     * Join together multiple FilterCriteria in one Predicate instance.
     */
    @XmlEnum
    public enum Conjunction {
        AND, OR;
        
        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
            return  " " + this.name() + " ";
        }
    }
}